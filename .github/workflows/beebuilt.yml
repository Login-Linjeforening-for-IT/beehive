name: BeeBuilt CI/CD Pipeline

on:
  push:
    branches: ["dev", "main"]
  pull_request:
    branches: ["dev", "main"]

env:
  GIT_USER_NAME: BeeBuilt Bot
  GIT_USER_EMAIL: beebuiltbot@login.no

jobs:
  fix-version:
    name: üß© Fix & Update Version
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.set_tag.outputs.new_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest versions
        id: get_versions
        run: |
          main_version=$(git show origin/main:package.json 2>/dev/null | jq -r '.version // "0.0.0"')
          dev_version=$(git show origin/dev:package.json 2>/dev/null | jq -r '.version // "0.0.0"')
          echo "main_tag=$main_version" >> $GITHUB_ENV
          echo "dev_tag=$dev_version" >> $GITHUB_ENV

      - name: Calculate new version
        id: bump
        run: |
          branch=$(git rev-parse --abbrev-ref HEAD)
          main_tag="${main_tag:-0.0.0}"
          dev_tag="${dev_tag:-0.0.0}"
          skip_commit=false

          IFS='.' read -r main_major main_minor main_patch <<< "$main_tag"
          IFS='.' read -r dev_major dev_minor dev_patch <<< "$dev_tag"

          main_major=${main_major:-0}
          main_minor=${main_minor:-0}
          main_patch=${main_patch:-0}

          dev_major=${dev_major:-0}
          dev_minor=${dev_minor:-0}
          dev_patch=${dev_patch:-0}

          changed_files=$(git diff --name-only origin/$branch...HEAD | wc -l)

          if [ "$branch" = "main" ]; then
            if git merge-base --is-ancestor origin/main origin/dev; then
              # Main behind dev ‚Üí merge dev
              git config --global user.name "$GIT_USER_NAME"
              git config --global user.email "$GIT_USER_EMAIL"
              git merge --no-ff origin/dev -m "Merge dev into main to sync version $dev_tag"
              new_version="$dev_tag"
              skip_commit=true
            else
              # Main = Dev or Main > Dev
              if [ "$main_tag" = "$dev_tag" ]; then
                if [ "$changed_files" -lt 4 ]; then
                  patch=$((main_patch + 1))
                  minor=$main_minor
                else
                  patch=0
                  minor=$((main_minor + 1))
                fi
                new_version="$main_major.$minor.$patch"
              else
                # Main > Dev ‚Üí bump dev to match main
                new_version="$main_tag"
              fi
            fi
          elif [ "$branch" = "dev" ]; then
            if [ "$changed_files" -lt 4 ]; then
              patch=$((dev_patch + 1))
              minor=$dev_minor
            else
              patch=0
              minor=$((dev_minor + 1))
            fi
            new_version="$dev_major.$minor.$patch"
          else
            new_version="$main_tag"
          fi

          echo "new_version=$new_version" >> $GITHUB_ENV
          echo "skip_commit=$skip_commit" >> $GITHUB_ENV
          echo "Calculated new_version: $new_version"
          echo "::set-output name=new_tag::$new_version"

      - name: Update package.json and lock
        if: env.skip_commit != 'true'
        run: |
          for file in $(find . \( -name "package.json" -o -name "package-lock.json" \) \
            -not -path "*/node_modules/*" -not -path "*/vendor/*"); do
            sed -i "s/\"version\": \".*\"/\"version\": \"${new_version}\"/" "$file"
          done

      - name: Commit changes
        if: env.skip_commit != 'true'
        run: |
          git config --global user.name "$GIT_USER_NAME"
          git config --global user.email "$GIT_USER_EMAIL"
          git add $(find . \( -name "package.json" -o -name "package-lock.json" \) \
                      -not -path "*/node_modules/*" -not -path "*/vendor/*")
          git commit -m "v${new_version}" || echo "No changes to commit"
          git push origin $GITHUB_REF_NAME

      - name: Create Git Tags
        id: set_tag
        run: |
          git config --global user.name "$GIT_USER_NAME"
          git config --global user.email "$GIT_USER_EMAIL"
          branch=$(git rev-parse --abbrev-ref HEAD)
          main_tag="$new_version"

          # If on main branch, tag main commit
          if [ "$branch" = "main" ]; then
            git tag "$main_tag" || echo "Tag $main_tag already exists"
            git push origin "$main_tag"

            dev_tag="${main_tag}-dev"
            if ! git tag -l | grep -q "^$dev_tag$"; then
              git tag "$dev_tag"
              git push origin "$dev_tag"
            fi
          fi

          # Always tag dev
          dev_tag="${new_version}-dev"
          git tag "$dev_tag" || echo "Tag $dev_tag already exists"
          git push origin "$dev_tag"

          echo "::set-output name=new_tag::$new_version"

  rebase:
    name: üîÑ Rebase from main to dev
    runs-on: ubuntu-latest
    needs: fix-version
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout dev
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0

      - name: Configure git
        run: |
          git config --global user.name "$GIT_USER_NAME"
          git config --global user.email "$GIT_USER_EMAIL"

      - name: Rebase from main to dev
        run: |
          git rebase origin/main

      - name: Push dev
        run: |
          git pull --rebase
          git push origin dev

  build:
    name: üê≥ Build Containers
    runs-on: ubuntu-latest
    needs: fix-version

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: 1Password Secrets Action
        uses: 1Password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: List 1Password items in repo vault
        run: |
          REPO_NAME="${GITHUB_REPOSITORY##*/}"
          echo "Looking for 1Password items in vault: $REPO_NAME"

      - name: Create .env file
        run: |
          echo "Generating .env file for Docker Compose"
          cat <<EOF > .env
          DOCKER_USER=${DOCKER_USER}
          DOCKER_PASS=${DOCKER_PASS}
          DISCORD_WEBHOOK=${DISCORD_WEBHOOK}
          EOF
          echo ".env file created:"
          cat .env

      - name: Login to Docker
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login "${{ secrets.DOCKER_REGISTRY }}" -u "${{ secrets.DOCKER_USER }}" --password-stdin
        
      - name: Build with Docker Compose
        run: docker compose up -d --build

      - name: Check exposed ports
        run: |
          sudo apt-get install -y curl
          ports=$(docker compose ps --format json \
            | jq -sr '.[] | .Publishers? // [] | .[] | .PublishedPort' \
            | sort -u)

          for port in $ports; do
            echo "üïì Waiting for port $port to respond..."

            # Try up to 10 times with 5 seconds between
            for i in {1..10}; do
              code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:$port || echo "000")
              if [ "$code" = "200" ]; then
                echo "‚úÖ Port $port is ready (HTTP $code)"
                break
              else
                echo "‚è≥ Attempt $i: got code $code, retrying in 5s..."
                sleep 5
              fi
            done

            if [ "$code" != "200" ]; then
              echo "‚ùå Port $port failed with code $code after retries"
              curl -H "Content-Type: application/json" \
                -X POST \
                -d "{\"embeds\":[{\"title\":\"Validation Failed\",\"description\":\"Port $port returned code $code after retries\"}]}" \
                "$DISCORD_WEBHOOK"
              exit 1
            fi
          done

      - name: Install pup
        run: |
          curl -LO https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_linux_amd64.zip
          unzip pup_v0.4.0_linux_amd64.zip
          chmod +x pup
          sudo mv pup /usr/local/bin/
          pup --help

      - name: Validate UI routes & elements
        run: |
          echo "Curl path: $(which curl)"
          if nc -z localhost 3000; then
            echo "Port 3000 is open, proceeding with validation..."
            SPEC=$(cat .test.json)
            for ROUTE in $(echo "$SPEC" | jq -r 'keys[]'); do
              echo "Checking $ROUTE ..."
              curl -s "http://localhost:3000$ROUTE" -o /tmp/page.html
              for ELEM in $(echo "$SPEC" | jq -r --arg path "$ROUTE" '.[$path][]'); do
                echo "  Checking element $ELEM ..."
                FOUND=$(pup "[test-id=\"$ELEM\"]" < /tmp/page.html | wc -l)
                if [ "$FOUND" -eq 0 ]; then
                  echo "‚ùå Element $ELEM not found at $ROUTE"
                  exit 1
                fi
              done
            done
          else
            echo "Port 3000 not open ‚Äî skipping route validation."
          fi

      - name: Collect logs
        run: |
          mkdir -p logs
          docker ps --format '{{.Names}}' | while read name; do
            echo "Capturing $name"
            docker logs $name > "logs/${name}.log" || true
          done

      - name: Tag & Push
        run: |
          IMAGE="${{ secrets.DOCKER_REGISTRY }}/tekkom/dev/"
          VERSION=${{ needs.fix-version.outputs.new_tag }}

          echo "Image: $IMAGE"
          echo "Version: $VERSION"

          docker compose build

          SERVICES=$(docker compose config --services)

          if [ -z "$SERVICES" ]; then
            echo "‚ùå No services found in docker-compose.yml"
            exit 1
          fi

          for SERVICE in $SERVICES; do
            echo "Processing service: $SERVICE"
            IMAGE_ID=$(docker compose images -q $SERVICE)
            if [ -z "$IMAGE_ID" ]; then
              echo "‚ùå No image found for service $SERVICE"
              exit 1
            fi

            docker tag "$IMAGE_ID" "$IMAGE$SERVICE:$VERSION"
            docker push "$IMAGE$SERVICE:$VERSION"
          done

  update:
    name: üîÑ Update Kubernetes Repo
    runs-on: ubuntu-latest
    # needs: [build, fix-version]
    steps:
      - name: Determine repo path
        id: set_repo
        run: |
          if [ "${GITHUB_REF##*/}" = "main" ]; then
            echo "repo_name=infra-prod-cluster" >> $GITHUB_ENV
          else
            echo "repo_name=test-cluster" >> $GITHUB_ENV
          fi

      - name: Checkout ${{ env.repo_name }}
        uses: actions/checkout@v4
        with:
          repository: Login-Linjeforening-for-IT/${{ env.repo_name }}
          token: ${{ secrets.PAT }}
          path: ${{ env.repo_name }}

      - name: Update image version
        env:
          PAT: ${{ secrets.PAT }}
          DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
        run: |
          set -e
          PROJECT_NAME="${GITHUB_REPOSITORY##*/}"
          NEW_TAG="${{ needs.fix-version.outputs.new_tag }}"
          REGISTRY="${DOCKER_REGISTRY}/tekkom/dev"
          BRANCH="main"

          cd "${{ env.repo_name }}/cluster/$PROJECT_NAME"
          git checkout -B "$BRANCH"

          echo "üîç Searching for deployment.yaml files in $(pwd)..."
          find . -type f -name "deployment.yaml" | while read -r FILE; do
            echo "üìÑ Checking $FILE..."
            
            IMAGE_LINE=$(yq e '.spec.template.spec.containers[].image' "$FILE" 2>/dev/null || true)
            if echo "$IMAGE_LINE" | grep -q "${REGISTRY}/${PROJECT_NAME}/"; then
              echo "‚úÖ Found matching image in $FILE"
              yq e -i \
                ".spec.template.spec.containers[].image |= sub(\":.*$\"; \":${NEW_TAG}\")" \
                "$FILE"
              git add "$FILE"
            else
              echo "‚Ü©Ô∏è  Skipping $FILE (no matching image)"
            fi
          done

          git config --global user.name "$GIT_USER_NAME"
          git config --global user.email "$GIT_USER_EMAIL"

          if git diff --cached --quiet; then
            echo "‚úÖ No image updates needed."
          else
            echo "üîë Using PAT to push changes..."
            git remote set-url origin "https://Login-Linjeforening-for-IT:${PAT}@github.com/Login-Linjeforening-for-IT/${{ env.repo_name }}.git"
            git commit -m "Update ${PROJECT_NAME} image tag to ${NEW_TAG}"
            git push -u origin "$BRANCH"
          fi
