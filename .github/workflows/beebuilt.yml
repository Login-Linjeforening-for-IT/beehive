name: BeeBuilt CI/CD Pipeline

on:
  push:
    branches: ["dev", "main"]
  pull_request:
    branches: ["dev", "main"]

env:
  GIT_USER_NAME: BeeBuilt Bot
  GIT_USER_EMAIL: beebuiltbot@login.no

jobs:
  fix-version:
    name: üß© Fix & Update Version
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.bump.outputs.new_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag
        id: get_tag
        run: |
          latest=$(jq -r '.version' package.json)
          echo "latest_tag=$latest" >> $GITHUB_ENV

      - name: Bump version
        id: bump
        run: |
          version=${latest_tag#v}
          IFS='.' read -r major minor patch <<< "$version"
          changed_files=$(git diff --name-only $latest_tag..HEAD | wc -l)
          if [ "$changed_files" -lt 4 ]; then
            patch=$((patch+1))
          else
            minor=$((minor+1))
            patch=0
          fi
          if [ "$GITHUB_REF" == "refs/heads/main" ]; then
            suffix=""
          else
            suffix="-dev"
          fi
          new_tag="$major.$minor.$patch$suffix"
          echo "new_tag=$new_tag" >> $GITHUB_ENV
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT
          echo "Bumped to $new_tag"

      - name: Update package.json
        run: |
          find . -name "package.json" -not -path "*/node_modules/*" -not -path "*/vendor/*" -exec sh -c '
            file="$1"
            new_ver="${2#v}"
            if ! sed -n "3p" "$file" | grep -q "\"version\":"; then
              echo "Version not at line 3 in $file"
              exit 1
            fi
            sed -i "3s/\"version\": \"[^\"]*\"/\"version\": \"$new_ver\"/" "$file"
          ' _ {} "${new_tag}" \;

      - name: Update lock file
        run: |
          find . -name "package-lock.json" -not -path "*/node_modules/*" -not -path "*/vendor/*" -exec sh -c '
            file="$1"
            new_ver="${2#v}"
            if ! sed -n "3p" "$file" | grep -q "\"version\":"; then
              echo "Version not at line 3 in $file"
              exit 1
            fi
            if ! sed -n "9p" "$file" | grep -q "\"version\":"; then
              echo "Version not at line 9 in $file"
              exit 1
            fi
            sed -i "3s/\"version\": \"[^\"]*\"/\"version\": \"$new_ver\"/" "$file"
            sed -i "9s/\"version\": \"[^\"]*\"/\"version\": \"$new_ver\"/" "$file"
          ' _ {} "${new_tag}" \;

      - name: Commit changes
        run: |
          git config --global user.name "$GIT_USER_NAME"
          git config --global user.email "$GIT_USER_EMAIL"
          git add $(find . -name "package.json" -o -name "package-lock.json" | grep -v node_modules | grep -v vendor)
          git commit -m "v$new_tag" || echo "No changes to commit"
          git push origin main

      - name: Create Git Tag
        run: |
          git config --global user.name "$GIT_USER_NAME"
          git config --global user.email "$GIT_USER_EMAIL"
          git tag ${{ env.new_tag }}
          git push origin ${{ env.new_tag }}

      - name: Create dev tag if not exists
        if: github.ref == 'refs/heads/main'
        run: |
          dev_tag="${{ env.new_tag }}-dev"
          if ! git tag -l | grep -q "^${dev_tag}$"; then
            git tag $dev_tag
            git push origin $dev_tag
          fi

  rebase:
    name: üîÑ Rebase from main to dev
    runs-on: ubuntu-latest
    needs: fix-version
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout dev
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0

      - name: Configure git
        run: |
          git config --global user.name "$GIT_USER_NAME"
          git config --global user.email "$GIT_USER_EMAIL"

      - name: Rebase from main to dev
        run: |
          git rebase origin/main

      - name: Push dev
        run: git push origin dev

  build:
    name: üê≥ Build Containers
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: 1Password Secrets Action
        uses: 1Password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: List 1Password items in repo vault
        run: |
          # Use repo name as vault/item prefix
          REPO_NAME="${GITHUB_REPOSITORY##*/}"
          echo "Looking for 1Password items in vault: $REPO_NAME"

      - name: Create .env file
        run: |
          echo "Generating .env file for Docker Compose"
          cat <<EOF > .env
          DOCKER_USER=${DOCKER_USER}
          DOCKER_PASS=${DOCKER_PASS}
          DISCORD_WEBHOOK=${DISCORD_WEBHOOK}
          EOF
          echo ".env file created:"
          cat .env

      - name: Login to Docker
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login "${{ secrets.DOCKER_REGISTRY }}" -u "${{ secrets.DOCKER_USER }}" --password-stdin
        
      - name: Build with Docker Compose
        run: docker compose up -d --build

  validate:
    name: üîç Validate Deployment
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Wait for services
        run: sleep 10

      - name: Check exposed ports
        run: |
          ports=$(docker compose ps --format json | jq -r '.[].Publishers[].PublishedPort')
          for port in $ports; do
            echo "Checking port $port..."
            code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:$port)
            if [ "$code" != "200" ]; then
              echo "‚ùå Port $port failed with code $code"
              curl -H "Content-Type: application/json" \
                -X POST \
                -d "{\"embeds\":[{\"title\":\"Validation Failed\",\"description\":\"Port $port returned code $code\"}]}" \
                ${{ secrets.DISCORD_WEBHOOK }}
              exit 1
            fi
          done

      - name: Install pup
        run: |
          curl -LO https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_linux_amd64.zip
          unzip pup_v0.4.0_linux_amd64.zip
          chmod +x pup
          sudo mv pup /usr/local/bin/
          pup --help

      - name: Validate routes & elements
        run: |
          # Check if port 3000 is open
          if nc -z localhost 3000; then
            echo "Port 3000 is open, proceeding with validation..."
            
            # Read the JSON spec
            SPEC=$(cat .test.json)

            # Loop over paths
            for PATH in $(echo "$SPEC" | jq -r 'keys[]'); do
              echo "Checking $PATH ..."
              # Request HTML
              HTML=$(curl -s "http://localhost:3000$PATH")
              
              # Loop over expected elements
              for ELEM in $(echo "$SPEC" | jq -r --arg path "$PATH" '.[$path][]'); do
                echo "  Checking element $ELEM ..."
                FOUND=$(echo "$HTML" | pup "[data-testid=\"$ELEM\"]" | wc -l)
                if [ "$FOUND" -eq 0 ]; then
                  echo "‚ùå Element $ELEM not found at $PATH"
                  exit 1
                fi
              done
            done
          else
            echo "Port 3000 not open ‚Äî skipping route validation."
          fi

      - name: Collect logs
        run: |
          mkdir -p logs
          docker ps --format '{{.Names}}' | while read name; do
            echo "Capturing $name"
            docker logs $name > "logs/${name}.log" || true
          done

  tag:
    name: üè∑Ô∏è Tag & Push Image
    runs-on: ubuntu-latest
    needs: [build, validate, fix-version]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to GitLab Registry
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login "${{ secrets.DOCKER_REGISTRY }}" -u "${{ secrets.DOCKER_USER }}" --password-stdin

      - name: Tag & Push
        run: |
          IMAGE="${{ secrets.DOCKER_REGISTRY }}/tekkom/dev/${{ github.ref_name }}"
          VERSION=${{ needs.fix-version.outputs.new_tag }}

          echo "Image: $IMAGE"
          echo "Version: $VERSION"

          # Build all services
          docker compose build

          # Get all service names from docker-compose.yml
          SERVICES=$(docker compose config --services)

          if [ -z "$SERVICES" ]; then
            echo "‚ùå No services found in docker-compose.yml"
            exit 1
          fi

          # Loop over services and tag/push each
          for SERVICE in $SERVICES; do
            echo "Processing service: $SERVICE"
            IMAGE_ID=$(docker compose images -q $SERVICE)
            if [ -z "$IMAGE_ID" ]; then
              echo "‚ùå No image found for service $SERVICE"
              exit 1
            fi

            docker tag "$IMAGE_ID" "$IMAGE-$SERVICE:$VERSION"
            docker push "$IMAGE-$SERVICE:$VERSION"
          done

  update:
    name: üîÑ Update Kubernetes Repo
    runs-on: ubuntu-latest
    needs: [tag, fix-version]
    steps:
      - name: Determine repo path
        id: set_repo
        run: |
          if [ "${GITHUB_REF##*/}" = "here" ]; then
            echo "repo_name=infra-prod-cluster" >> $GITHUB_ENV
          else
            echo "repo_name=test-cluster" >> $GITHUB_ENV
          fi

      - name: Checkout kube repo
        uses: actions/checkout@v4
        with:
          repository: Login-Linjeforening-for-IT/${{ env.repo_name }}
          token: ${{ secrets.GITHUB_TOKEN }}
          path: kuberepo

      - name: Update image version
        run: |
          cd kuberepo
          yq e -i '.spec.template.spec.containers[0].image = "${{ secrets.DOCKER_REGISTRY }}/${GITHUB_REF##*/}:${{ needs.fix-version.outputs.new_tag }}"' deployment.yaml
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git commit -am "Update BeeBuilt image to ${{ needs.fix-version.outputs.new_tag }}"
          git push
